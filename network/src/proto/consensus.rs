// This file is generated by rust-protobuf 2.7.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `consensus.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_7_0;

#[derive(PartialEq,Clone,Default)]
pub struct ConsensusMsg {
    // message oneof groups
    pub message: ::std::option::Option<ConsensusMsg_oneof_message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConsensusMsg {
    fn default() -> &'a ConsensusMsg {
        <ConsensusMsg as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ConsensusMsg_oneof_message {
    proposal(Proposal),
    vote(Vote),
    request_block(RequestBlock),
    respond_block(RespondBlock),
    timeout_msg(TimeoutMsg),
    request_chunk(RequestChunk),
    respond_chunk(RespondChunk),
    sync_info(SyncInfo),
}

impl ConsensusMsg {
    pub fn new() -> ConsensusMsg {
        ::std::default::Default::default()
    }

    // .network.Proposal proposal = 1;


    pub fn get_proposal(&self) -> &Proposal {
        match self.message {
            ::std::option::Option::Some(ConsensusMsg_oneof_message::proposal(ref v)) => v,
            _ => Proposal::default_instance(),
        }
    }
    pub fn clear_proposal(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_proposal(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(ConsensusMsg_oneof_message::proposal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_proposal(&mut self, v: Proposal) {
        self.message = ::std::option::Option::Some(ConsensusMsg_oneof_message::proposal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_proposal(&mut self) -> &mut Proposal {
        if let ::std::option::Option::Some(ConsensusMsg_oneof_message::proposal(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(ConsensusMsg_oneof_message::proposal(Proposal::new()));
        }
        match self.message {
            ::std::option::Option::Some(ConsensusMsg_oneof_message::proposal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_proposal(&mut self) -> Proposal {
        if self.has_proposal() {
            match self.message.take() {
                ::std::option::Option::Some(ConsensusMsg_oneof_message::proposal(v)) => v,
                _ => panic!(),
            }
        } else {
            Proposal::new()
        }
    }

    // .network.Vote vote = 2;


    pub fn get_vote(&self) -> &Vote {
        match self.message {
            ::std::option::Option::Some(ConsensusMsg_oneof_message::vote(ref v)) => v,
            _ => Vote::default_instance(),
        }
    }
    pub fn clear_vote(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_vote(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(ConsensusMsg_oneof_message::vote(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_vote(&mut self, v: Vote) {
        self.message = ::std::option::Option::Some(ConsensusMsg_oneof_message::vote(v))
    }

    // Mutable pointer to the field.
    pub fn mut_vote(&mut self) -> &mut Vote {
        if let ::std::option::Option::Some(ConsensusMsg_oneof_message::vote(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(ConsensusMsg_oneof_message::vote(Vote::new()));
        }
        match self.message {
            ::std::option::Option::Some(ConsensusMsg_oneof_message::vote(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_vote(&mut self) -> Vote {
        if self.has_vote() {
            match self.message.take() {
                ::std::option::Option::Some(ConsensusMsg_oneof_message::vote(v)) => v,
                _ => panic!(),
            }
        } else {
            Vote::new()
        }
    }

    // .network.RequestBlock request_block = 3;


    pub fn get_request_block(&self) -> &RequestBlock {
        match self.message {
            ::std::option::Option::Some(ConsensusMsg_oneof_message::request_block(ref v)) => v,
            _ => RequestBlock::default_instance(),
        }
    }
    pub fn clear_request_block(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_request_block(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(ConsensusMsg_oneof_message::request_block(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_request_block(&mut self, v: RequestBlock) {
        self.message = ::std::option::Option::Some(ConsensusMsg_oneof_message::request_block(v))
    }

    // Mutable pointer to the field.
    pub fn mut_request_block(&mut self) -> &mut RequestBlock {
        if let ::std::option::Option::Some(ConsensusMsg_oneof_message::request_block(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(ConsensusMsg_oneof_message::request_block(RequestBlock::new()));
        }
        match self.message {
            ::std::option::Option::Some(ConsensusMsg_oneof_message::request_block(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_request_block(&mut self) -> RequestBlock {
        if self.has_request_block() {
            match self.message.take() {
                ::std::option::Option::Some(ConsensusMsg_oneof_message::request_block(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestBlock::new()
        }
    }

    // .network.RespondBlock respond_block = 4;


    pub fn get_respond_block(&self) -> &RespondBlock {
        match self.message {
            ::std::option::Option::Some(ConsensusMsg_oneof_message::respond_block(ref v)) => v,
            _ => RespondBlock::default_instance(),
        }
    }
    pub fn clear_respond_block(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_respond_block(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(ConsensusMsg_oneof_message::respond_block(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_respond_block(&mut self, v: RespondBlock) {
        self.message = ::std::option::Option::Some(ConsensusMsg_oneof_message::respond_block(v))
    }

    // Mutable pointer to the field.
    pub fn mut_respond_block(&mut self) -> &mut RespondBlock {
        if let ::std::option::Option::Some(ConsensusMsg_oneof_message::respond_block(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(ConsensusMsg_oneof_message::respond_block(RespondBlock::new()));
        }
        match self.message {
            ::std::option::Option::Some(ConsensusMsg_oneof_message::respond_block(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_respond_block(&mut self) -> RespondBlock {
        if self.has_respond_block() {
            match self.message.take() {
                ::std::option::Option::Some(ConsensusMsg_oneof_message::respond_block(v)) => v,
                _ => panic!(),
            }
        } else {
            RespondBlock::new()
        }
    }

    // .network.TimeoutMsg timeout_msg = 5;


    pub fn get_timeout_msg(&self) -> &TimeoutMsg {
        match self.message {
            ::std::option::Option::Some(ConsensusMsg_oneof_message::timeout_msg(ref v)) => v,
            _ => TimeoutMsg::default_instance(),
        }
    }
    pub fn clear_timeout_msg(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_timeout_msg(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(ConsensusMsg_oneof_message::timeout_msg(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_timeout_msg(&mut self, v: TimeoutMsg) {
        self.message = ::std::option::Option::Some(ConsensusMsg_oneof_message::timeout_msg(v))
    }

    // Mutable pointer to the field.
    pub fn mut_timeout_msg(&mut self) -> &mut TimeoutMsg {
        if let ::std::option::Option::Some(ConsensusMsg_oneof_message::timeout_msg(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(ConsensusMsg_oneof_message::timeout_msg(TimeoutMsg::new()));
        }
        match self.message {
            ::std::option::Option::Some(ConsensusMsg_oneof_message::timeout_msg(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_timeout_msg(&mut self) -> TimeoutMsg {
        if self.has_timeout_msg() {
            match self.message.take() {
                ::std::option::Option::Some(ConsensusMsg_oneof_message::timeout_msg(v)) => v,
                _ => panic!(),
            }
        } else {
            TimeoutMsg::new()
        }
    }

    // .network.RequestChunk request_chunk = 6;


    pub fn get_request_chunk(&self) -> &RequestChunk {
        match self.message {
            ::std::option::Option::Some(ConsensusMsg_oneof_message::request_chunk(ref v)) => v,
            _ => RequestChunk::default_instance(),
        }
    }
    pub fn clear_request_chunk(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_request_chunk(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(ConsensusMsg_oneof_message::request_chunk(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_request_chunk(&mut self, v: RequestChunk) {
        self.message = ::std::option::Option::Some(ConsensusMsg_oneof_message::request_chunk(v))
    }

    // Mutable pointer to the field.
    pub fn mut_request_chunk(&mut self) -> &mut RequestChunk {
        if let ::std::option::Option::Some(ConsensusMsg_oneof_message::request_chunk(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(ConsensusMsg_oneof_message::request_chunk(RequestChunk::new()));
        }
        match self.message {
            ::std::option::Option::Some(ConsensusMsg_oneof_message::request_chunk(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_request_chunk(&mut self) -> RequestChunk {
        if self.has_request_chunk() {
            match self.message.take() {
                ::std::option::Option::Some(ConsensusMsg_oneof_message::request_chunk(v)) => v,
                _ => panic!(),
            }
        } else {
            RequestChunk::new()
        }
    }

    // .network.RespondChunk respond_chunk = 7;


    pub fn get_respond_chunk(&self) -> &RespondChunk {
        match self.message {
            ::std::option::Option::Some(ConsensusMsg_oneof_message::respond_chunk(ref v)) => v,
            _ => RespondChunk::default_instance(),
        }
    }
    pub fn clear_respond_chunk(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_respond_chunk(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(ConsensusMsg_oneof_message::respond_chunk(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_respond_chunk(&mut self, v: RespondChunk) {
        self.message = ::std::option::Option::Some(ConsensusMsg_oneof_message::respond_chunk(v))
    }

    // Mutable pointer to the field.
    pub fn mut_respond_chunk(&mut self) -> &mut RespondChunk {
        if let ::std::option::Option::Some(ConsensusMsg_oneof_message::respond_chunk(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(ConsensusMsg_oneof_message::respond_chunk(RespondChunk::new()));
        }
        match self.message {
            ::std::option::Option::Some(ConsensusMsg_oneof_message::respond_chunk(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_respond_chunk(&mut self) -> RespondChunk {
        if self.has_respond_chunk() {
            match self.message.take() {
                ::std::option::Option::Some(ConsensusMsg_oneof_message::respond_chunk(v)) => v,
                _ => panic!(),
            }
        } else {
            RespondChunk::new()
        }
    }

    // .network.SyncInfo sync_info = 8;


    pub fn get_sync_info(&self) -> &SyncInfo {
        match self.message {
            ::std::option::Option::Some(ConsensusMsg_oneof_message::sync_info(ref v)) => v,
            _ => SyncInfo::default_instance(),
        }
    }
    pub fn clear_sync_info(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_sync_info(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(ConsensusMsg_oneof_message::sync_info(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sync_info(&mut self, v: SyncInfo) {
        self.message = ::std::option::Option::Some(ConsensusMsg_oneof_message::sync_info(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sync_info(&mut self) -> &mut SyncInfo {
        if let ::std::option::Option::Some(ConsensusMsg_oneof_message::sync_info(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(ConsensusMsg_oneof_message::sync_info(SyncInfo::new()));
        }
        match self.message {
            ::std::option::Option::Some(ConsensusMsg_oneof_message::sync_info(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sync_info(&mut self) -> SyncInfo {
        if self.has_sync_info() {
            match self.message.take() {
                ::std::option::Option::Some(ConsensusMsg_oneof_message::sync_info(v)) => v,
                _ => panic!(),
            }
        } else {
            SyncInfo::new()
        }
    }
}

impl ::protobuf::Message for ConsensusMsg {
    fn is_initialized(&self) -> bool {
        if let Some(ConsensusMsg_oneof_message::proposal(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConsensusMsg_oneof_message::vote(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConsensusMsg_oneof_message::request_block(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConsensusMsg_oneof_message::respond_block(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConsensusMsg_oneof_message::timeout_msg(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConsensusMsg_oneof_message::request_chunk(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConsensusMsg_oneof_message::respond_chunk(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ConsensusMsg_oneof_message::sync_info(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(ConsensusMsg_oneof_message::proposal(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(ConsensusMsg_oneof_message::vote(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(ConsensusMsg_oneof_message::request_block(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(ConsensusMsg_oneof_message::respond_block(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(ConsensusMsg_oneof_message::timeout_msg(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(ConsensusMsg_oneof_message::request_chunk(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(ConsensusMsg_oneof_message::respond_chunk(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(ConsensusMsg_oneof_message::sync_info(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &ConsensusMsg_oneof_message::proposal(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConsensusMsg_oneof_message::vote(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConsensusMsg_oneof_message::request_block(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConsensusMsg_oneof_message::respond_block(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConsensusMsg_oneof_message::timeout_msg(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConsensusMsg_oneof_message::request_chunk(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConsensusMsg_oneof_message::respond_chunk(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ConsensusMsg_oneof_message::sync_info(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &ConsensusMsg_oneof_message::proposal(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConsensusMsg_oneof_message::vote(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConsensusMsg_oneof_message::request_block(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConsensusMsg_oneof_message::respond_block(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConsensusMsg_oneof_message::timeout_msg(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConsensusMsg_oneof_message::request_chunk(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConsensusMsg_oneof_message::respond_chunk(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ConsensusMsg_oneof_message::sync_info(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConsensusMsg {
        ConsensusMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Proposal>(
                    "proposal",
                    ConsensusMsg::has_proposal,
                    ConsensusMsg::get_proposal,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Vote>(
                    "vote",
                    ConsensusMsg::has_vote,
                    ConsensusMsg::get_vote,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RequestBlock>(
                    "request_block",
                    ConsensusMsg::has_request_block,
                    ConsensusMsg::get_request_block,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RespondBlock>(
                    "respond_block",
                    ConsensusMsg::has_respond_block,
                    ConsensusMsg::get_respond_block,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TimeoutMsg>(
                    "timeout_msg",
                    ConsensusMsg::has_timeout_msg,
                    ConsensusMsg::get_timeout_msg,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RequestChunk>(
                    "request_chunk",
                    ConsensusMsg::has_request_chunk,
                    ConsensusMsg::get_request_chunk,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RespondChunk>(
                    "respond_chunk",
                    ConsensusMsg::has_respond_chunk,
                    ConsensusMsg::get_respond_chunk,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SyncInfo>(
                    "sync_info",
                    ConsensusMsg::has_sync_info,
                    ConsensusMsg::get_sync_info,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConsensusMsg>(
                    "ConsensusMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConsensusMsg {
        static mut instance: ::protobuf::lazy::Lazy<ConsensusMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConsensusMsg,
        };
        unsafe {
            instance.get(ConsensusMsg::new)
        }
    }
}

impl ::protobuf::Clear for ConsensusMsg {
    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConsensusMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConsensusMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Proposal {
    // message fields
    pub proposed_block: ::protobuf::SingularPtrField<Block>,
    pub proposer: ::bytes::Bytes,
    pub sync_info: ::protobuf::SingularPtrField<SyncInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Proposal {
    fn default() -> &'a Proposal {
        <Proposal as ::protobuf::Message>::default_instance()
    }
}

impl Proposal {
    pub fn new() -> Proposal {
        ::std::default::Default::default()
    }

    // .network.Block proposed_block = 1;


    pub fn get_proposed_block(&self) -> &Block {
        self.proposed_block.as_ref().unwrap_or_else(|| Block::default_instance())
    }
    pub fn clear_proposed_block(&mut self) {
        self.proposed_block.clear();
    }

    pub fn has_proposed_block(&self) -> bool {
        self.proposed_block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proposed_block(&mut self, v: Block) {
        self.proposed_block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proposed_block(&mut self) -> &mut Block {
        if self.proposed_block.is_none() {
            self.proposed_block.set_default();
        }
        self.proposed_block.as_mut().unwrap()
    }

    // Take field
    pub fn take_proposed_block(&mut self) -> Block {
        self.proposed_block.take().unwrap_or_else(|| Block::new())
    }

    // bytes proposer = 2;


    pub fn get_proposer(&self) -> &[u8] {
        &self.proposer
    }
    pub fn clear_proposer(&mut self) {
        self.proposer.clear();
    }

    // Param is passed by value, moved
    pub fn set_proposer(&mut self, v: ::bytes::Bytes) {
        self.proposer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proposer(&mut self) -> &mut ::bytes::Bytes {
        &mut self.proposer
    }

    // Take field
    pub fn take_proposer(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.proposer, ::bytes::Bytes::new())
    }

    // .network.SyncInfo sync_info = 3;


    pub fn get_sync_info(&self) -> &SyncInfo {
        self.sync_info.as_ref().unwrap_or_else(|| SyncInfo::default_instance())
    }
    pub fn clear_sync_info(&mut self) {
        self.sync_info.clear();
    }

    pub fn has_sync_info(&self) -> bool {
        self.sync_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sync_info(&mut self, v: SyncInfo) {
        self.sync_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sync_info(&mut self) -> &mut SyncInfo {
        if self.sync_info.is_none() {
            self.sync_info.set_default();
        }
        self.sync_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_sync_info(&mut self) -> SyncInfo {
        self.sync_info.take().unwrap_or_else(|| SyncInfo::new())
    }
}

impl ::protobuf::Message for Proposal {
    fn is_initialized(&self) -> bool {
        for v in &self.proposed_block {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sync_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.proposed_block)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.proposer)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sync_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.proposed_block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.proposer.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.proposer);
        }
        if let Some(ref v) = self.sync_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.proposed_block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.proposer.is_empty() {
            os.write_bytes(2, &self.proposer)?;
        }
        if let Some(ref v) = self.sync_info.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Proposal {
        Proposal::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Block>>(
                    "proposed_block",
                    |m: &Proposal| { &m.proposed_block },
                    |m: &mut Proposal| { &mut m.proposed_block },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "proposer",
                    |m: &Proposal| { &m.proposer },
                    |m: &mut Proposal| { &mut m.proposer },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncInfo>>(
                    "sync_info",
                    |m: &Proposal| { &m.sync_info },
                    |m: &mut Proposal| { &mut m.sync_info },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Proposal>(
                    "Proposal",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Proposal {
        static mut instance: ::protobuf::lazy::Lazy<Proposal> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Proposal,
        };
        unsafe {
            instance.get(Proposal::new)
        }
    }
}

impl ::protobuf::Clear for Proposal {
    fn clear(&mut self) {
        self.proposed_block.clear();
        self.proposer.clear();
        self.sync_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Proposal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Proposal {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PacemakerTimeout {
    // message fields
    pub round: u64,
    pub author: ::bytes::Bytes,
    pub signature: ::bytes::Bytes,
    pub vote: ::protobuf::SingularPtrField<Vote>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PacemakerTimeout {
    fn default() -> &'a PacemakerTimeout {
        <PacemakerTimeout as ::protobuf::Message>::default_instance()
    }
}

impl PacemakerTimeout {
    pub fn new() -> PacemakerTimeout {
        ::std::default::Default::default()
    }

    // uint64 round = 1;


    pub fn get_round(&self) -> u64 {
        self.round
    }
    pub fn clear_round(&mut self) {
        self.round = 0;
    }

    // Param is passed by value, moved
    pub fn set_round(&mut self, v: u64) {
        self.round = v;
    }

    // bytes author = 2;


    pub fn get_author(&self) -> &[u8] {
        &self.author
    }
    pub fn clear_author(&mut self) {
        self.author.clear();
    }

    // Param is passed by value, moved
    pub fn set_author(&mut self, v: ::bytes::Bytes) {
        self.author = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_author(&mut self) -> &mut ::bytes::Bytes {
        &mut self.author
    }

    // Take field
    pub fn take_author(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.author, ::bytes::Bytes::new())
    }

    // bytes signature = 3;


    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::bytes::Bytes) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::bytes::Bytes {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.signature, ::bytes::Bytes::new())
    }

    // .network.Vote vote = 4;


    pub fn get_vote(&self) -> &Vote {
        self.vote.as_ref().unwrap_or_else(|| Vote::default_instance())
    }
    pub fn clear_vote(&mut self) {
        self.vote.clear();
    }

    pub fn has_vote(&self) -> bool {
        self.vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote(&mut self, v: Vote) {
        self.vote = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vote(&mut self) -> &mut Vote {
        if self.vote.is_none() {
            self.vote.set_default();
        }
        self.vote.as_mut().unwrap()
    }

    // Take field
    pub fn take_vote(&mut self) -> Vote {
        self.vote.take().unwrap_or_else(|| Vote::new())
    }
}

impl ::protobuf::Message for PacemakerTimeout {
    fn is_initialized(&self) -> bool {
        for v in &self.vote {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.round = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.author)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.signature)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vote)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.round != 0 {
            my_size += ::protobuf::rt::value_size(1, self.round, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.author.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.author);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.signature);
        }
        if let Some(ref v) = self.vote.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.round != 0 {
            os.write_uint64(1, self.round)?;
        }
        if !self.author.is_empty() {
            os.write_bytes(2, &self.author)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(3, &self.signature)?;
        }
        if let Some(ref v) = self.vote.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PacemakerTimeout {
        PacemakerTimeout::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "round",
                    |m: &PacemakerTimeout| { &m.round },
                    |m: &mut PacemakerTimeout| { &mut m.round },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "author",
                    |m: &PacemakerTimeout| { &m.author },
                    |m: &mut PacemakerTimeout| { &mut m.author },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "signature",
                    |m: &PacemakerTimeout| { &m.signature },
                    |m: &mut PacemakerTimeout| { &mut m.signature },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Vote>>(
                    "vote",
                    |m: &PacemakerTimeout| { &m.vote },
                    |m: &mut PacemakerTimeout| { &mut m.vote },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PacemakerTimeout>(
                    "PacemakerTimeout",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PacemakerTimeout {
        static mut instance: ::protobuf::lazy::Lazy<PacemakerTimeout> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PacemakerTimeout,
        };
        unsafe {
            instance.get(PacemakerTimeout::new)
        }
    }
}

impl ::protobuf::Clear for PacemakerTimeout {
    fn clear(&mut self) {
        self.round = 0;
        self.author.clear();
        self.signature.clear();
        self.vote.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PacemakerTimeout {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PacemakerTimeout {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimeoutMsg {
    // message fields
    pub sync_info: ::protobuf::SingularPtrField<SyncInfo>,
    pub pacemaker_timeout: ::protobuf::SingularPtrField<PacemakerTimeout>,
    pub signature: ::bytes::Bytes,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimeoutMsg {
    fn default() -> &'a TimeoutMsg {
        <TimeoutMsg as ::protobuf::Message>::default_instance()
    }
}

impl TimeoutMsg {
    pub fn new() -> TimeoutMsg {
        ::std::default::Default::default()
    }

    // .network.SyncInfo sync_info = 1;


    pub fn get_sync_info(&self) -> &SyncInfo {
        self.sync_info.as_ref().unwrap_or_else(|| SyncInfo::default_instance())
    }
    pub fn clear_sync_info(&mut self) {
        self.sync_info.clear();
    }

    pub fn has_sync_info(&self) -> bool {
        self.sync_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sync_info(&mut self, v: SyncInfo) {
        self.sync_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sync_info(&mut self) -> &mut SyncInfo {
        if self.sync_info.is_none() {
            self.sync_info.set_default();
        }
        self.sync_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_sync_info(&mut self) -> SyncInfo {
        self.sync_info.take().unwrap_or_else(|| SyncInfo::new())
    }

    // .network.PacemakerTimeout pacemaker_timeout = 2;


    pub fn get_pacemaker_timeout(&self) -> &PacemakerTimeout {
        self.pacemaker_timeout.as_ref().unwrap_or_else(|| PacemakerTimeout::default_instance())
    }
    pub fn clear_pacemaker_timeout(&mut self) {
        self.pacemaker_timeout.clear();
    }

    pub fn has_pacemaker_timeout(&self) -> bool {
        self.pacemaker_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pacemaker_timeout(&mut self, v: PacemakerTimeout) {
        self.pacemaker_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pacemaker_timeout(&mut self) -> &mut PacemakerTimeout {
        if self.pacemaker_timeout.is_none() {
            self.pacemaker_timeout.set_default();
        }
        self.pacemaker_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_pacemaker_timeout(&mut self) -> PacemakerTimeout {
        self.pacemaker_timeout.take().unwrap_or_else(|| PacemakerTimeout::new())
    }

    // bytes signature = 3;


    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::bytes::Bytes) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::bytes::Bytes {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.signature, ::bytes::Bytes::new())
    }
}

impl ::protobuf::Message for TimeoutMsg {
    fn is_initialized(&self) -> bool {
        for v in &self.sync_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pacemaker_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sync_info)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pacemaker_timeout)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.sync_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pacemaker_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.sync_info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pacemaker_timeout.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(3, &self.signature)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimeoutMsg {
        TimeoutMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncInfo>>(
                    "sync_info",
                    |m: &TimeoutMsg| { &m.sync_info },
                    |m: &mut TimeoutMsg| { &mut m.sync_info },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PacemakerTimeout>>(
                    "pacemaker_timeout",
                    |m: &TimeoutMsg| { &m.pacemaker_timeout },
                    |m: &mut TimeoutMsg| { &mut m.pacemaker_timeout },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "signature",
                    |m: &TimeoutMsg| { &m.signature },
                    |m: &mut TimeoutMsg| { &mut m.signature },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TimeoutMsg>(
                    "TimeoutMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TimeoutMsg {
        static mut instance: ::protobuf::lazy::Lazy<TimeoutMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TimeoutMsg,
        };
        unsafe {
            instance.get(TimeoutMsg::new)
        }
    }
}

impl ::protobuf::Clear for TimeoutMsg {
    fn clear(&mut self) {
        self.sync_info.clear();
        self.pacemaker_timeout.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimeoutMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeoutMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SyncInfo {
    // message fields
    pub highest_quorum_cert: ::protobuf::SingularPtrField<QuorumCert>,
    pub highest_ledger_info: ::protobuf::SingularPtrField<QuorumCert>,
    pub highest_timeout_cert: ::protobuf::SingularPtrField<PacemakerTimeoutCertificate>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncInfo {
    fn default() -> &'a SyncInfo {
        <SyncInfo as ::protobuf::Message>::default_instance()
    }
}

impl SyncInfo {
    pub fn new() -> SyncInfo {
        ::std::default::Default::default()
    }

    // .network.QuorumCert highest_quorum_cert = 1;


    pub fn get_highest_quorum_cert(&self) -> &QuorumCert {
        self.highest_quorum_cert.as_ref().unwrap_or_else(|| QuorumCert::default_instance())
    }
    pub fn clear_highest_quorum_cert(&mut self) {
        self.highest_quorum_cert.clear();
    }

    pub fn has_highest_quorum_cert(&self) -> bool {
        self.highest_quorum_cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_highest_quorum_cert(&mut self, v: QuorumCert) {
        self.highest_quorum_cert = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_highest_quorum_cert(&mut self) -> &mut QuorumCert {
        if self.highest_quorum_cert.is_none() {
            self.highest_quorum_cert.set_default();
        }
        self.highest_quorum_cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_highest_quorum_cert(&mut self) -> QuorumCert {
        self.highest_quorum_cert.take().unwrap_or_else(|| QuorumCert::new())
    }

    // .network.QuorumCert highest_ledger_info = 2;


    pub fn get_highest_ledger_info(&self) -> &QuorumCert {
        self.highest_ledger_info.as_ref().unwrap_or_else(|| QuorumCert::default_instance())
    }
    pub fn clear_highest_ledger_info(&mut self) {
        self.highest_ledger_info.clear();
    }

    pub fn has_highest_ledger_info(&self) -> bool {
        self.highest_ledger_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_highest_ledger_info(&mut self, v: QuorumCert) {
        self.highest_ledger_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_highest_ledger_info(&mut self) -> &mut QuorumCert {
        if self.highest_ledger_info.is_none() {
            self.highest_ledger_info.set_default();
        }
        self.highest_ledger_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_highest_ledger_info(&mut self) -> QuorumCert {
        self.highest_ledger_info.take().unwrap_or_else(|| QuorumCert::new())
    }

    // .network.PacemakerTimeoutCertificate highest_timeout_cert = 3;


    pub fn get_highest_timeout_cert(&self) -> &PacemakerTimeoutCertificate {
        self.highest_timeout_cert.as_ref().unwrap_or_else(|| PacemakerTimeoutCertificate::default_instance())
    }
    pub fn clear_highest_timeout_cert(&mut self) {
        self.highest_timeout_cert.clear();
    }

    pub fn has_highest_timeout_cert(&self) -> bool {
        self.highest_timeout_cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_highest_timeout_cert(&mut self, v: PacemakerTimeoutCertificate) {
        self.highest_timeout_cert = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_highest_timeout_cert(&mut self) -> &mut PacemakerTimeoutCertificate {
        if self.highest_timeout_cert.is_none() {
            self.highest_timeout_cert.set_default();
        }
        self.highest_timeout_cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_highest_timeout_cert(&mut self) -> PacemakerTimeoutCertificate {
        self.highest_timeout_cert.take().unwrap_or_else(|| PacemakerTimeoutCertificate::new())
    }
}

impl ::protobuf::Message for SyncInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.highest_quorum_cert {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.highest_ledger_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.highest_timeout_cert {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.highest_quorum_cert)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.highest_ledger_info)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.highest_timeout_cert)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.highest_quorum_cert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.highest_ledger_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.highest_timeout_cert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.highest_quorum_cert.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.highest_ledger_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.highest_timeout_cert.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncInfo {
        SyncInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QuorumCert>>(
                    "highest_quorum_cert",
                    |m: &SyncInfo| { &m.highest_quorum_cert },
                    |m: &mut SyncInfo| { &mut m.highest_quorum_cert },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QuorumCert>>(
                    "highest_ledger_info",
                    |m: &SyncInfo| { &m.highest_ledger_info },
                    |m: &mut SyncInfo| { &mut m.highest_ledger_info },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PacemakerTimeoutCertificate>>(
                    "highest_timeout_cert",
                    |m: &SyncInfo| { &m.highest_timeout_cert },
                    |m: &mut SyncInfo| { &mut m.highest_timeout_cert },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SyncInfo>(
                    "SyncInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SyncInfo {
        static mut instance: ::protobuf::lazy::Lazy<SyncInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SyncInfo,
        };
        unsafe {
            instance.get(SyncInfo::new)
        }
    }
}

impl ::protobuf::Clear for SyncInfo {
    fn clear(&mut self) {
        self.highest_quorum_cert.clear();
        self.highest_ledger_info.clear();
        self.highest_timeout_cert.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PacemakerTimeoutCertificate {
    // message fields
    pub round: u64,
    pub timeouts: ::protobuf::RepeatedField<PacemakerTimeout>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PacemakerTimeoutCertificate {
    fn default() -> &'a PacemakerTimeoutCertificate {
        <PacemakerTimeoutCertificate as ::protobuf::Message>::default_instance()
    }
}

impl PacemakerTimeoutCertificate {
    pub fn new() -> PacemakerTimeoutCertificate {
        ::std::default::Default::default()
    }

    // uint64 round = 1;


    pub fn get_round(&self) -> u64 {
        self.round
    }
    pub fn clear_round(&mut self) {
        self.round = 0;
    }

    // Param is passed by value, moved
    pub fn set_round(&mut self, v: u64) {
        self.round = v;
    }

    // repeated .network.PacemakerTimeout timeouts = 2;


    pub fn get_timeouts(&self) -> &[PacemakerTimeout] {
        &self.timeouts
    }
    pub fn clear_timeouts(&mut self) {
        self.timeouts.clear();
    }

    // Param is passed by value, moved
    pub fn set_timeouts(&mut self, v: ::protobuf::RepeatedField<PacemakerTimeout>) {
        self.timeouts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_timeouts(&mut self) -> &mut ::protobuf::RepeatedField<PacemakerTimeout> {
        &mut self.timeouts
    }

    // Take field
    pub fn take_timeouts(&mut self) -> ::protobuf::RepeatedField<PacemakerTimeout> {
        ::std::mem::replace(&mut self.timeouts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PacemakerTimeoutCertificate {
    fn is_initialized(&self) -> bool {
        for v in &self.timeouts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.round = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.timeouts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.round != 0 {
            my_size += ::protobuf::rt::value_size(1, self.round, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.timeouts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.round != 0 {
            os.write_uint64(1, self.round)?;
        }
        for v in &self.timeouts {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PacemakerTimeoutCertificate {
        PacemakerTimeoutCertificate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "round",
                    |m: &PacemakerTimeoutCertificate| { &m.round },
                    |m: &mut PacemakerTimeoutCertificate| { &mut m.round },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PacemakerTimeout>>(
                    "timeouts",
                    |m: &PacemakerTimeoutCertificate| { &m.timeouts },
                    |m: &mut PacemakerTimeoutCertificate| { &mut m.timeouts },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PacemakerTimeoutCertificate>(
                    "PacemakerTimeoutCertificate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PacemakerTimeoutCertificate {
        static mut instance: ::protobuf::lazy::Lazy<PacemakerTimeoutCertificate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PacemakerTimeoutCertificate,
        };
        unsafe {
            instance.get(PacemakerTimeoutCertificate::new)
        }
    }
}

impl ::protobuf::Clear for PacemakerTimeoutCertificate {
    fn clear(&mut self) {
        self.round = 0;
        self.timeouts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PacemakerTimeoutCertificate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PacemakerTimeoutCertificate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Block {
    // message fields
    pub id: ::bytes::Bytes,
    pub parent_id: ::bytes::Bytes,
    pub payload: ::bytes::Bytes,
    pub round: u64,
    pub height: u64,
    pub timestamp_usecs: u64,
    pub quorum_cert: ::protobuf::SingularPtrField<QuorumCert>,
    pub author: ::bytes::Bytes,
    pub signature: ::bytes::Bytes,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Block {
    fn default() -> &'a Block {
        <Block as ::protobuf::Message>::default_instance()
    }
}

impl Block {
    pub fn new() -> Block {
        ::std::default::Default::default()
    }

    // bytes id = 1;


    pub fn get_id(&self) -> &[u8] {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::bytes::Bytes) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::bytes::Bytes {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.id, ::bytes::Bytes::new())
    }

    // bytes parent_id = 2;


    pub fn get_parent_id(&self) -> &[u8] {
        &self.parent_id
    }
    pub fn clear_parent_id(&mut self) {
        self.parent_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent_id(&mut self, v: ::bytes::Bytes) {
        self.parent_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent_id(&mut self) -> &mut ::bytes::Bytes {
        &mut self.parent_id
    }

    // Take field
    pub fn take_parent_id(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.parent_id, ::bytes::Bytes::new())
    }

    // bytes payload = 3;


    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::bytes::Bytes) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::bytes::Bytes {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.payload, ::bytes::Bytes::new())
    }

    // uint64 round = 4;


    pub fn get_round(&self) -> u64 {
        self.round
    }
    pub fn clear_round(&mut self) {
        self.round = 0;
    }

    // Param is passed by value, moved
    pub fn set_round(&mut self, v: u64) {
        self.round = v;
    }

    // uint64 height = 5;


    pub fn get_height(&self) -> u64 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u64) {
        self.height = v;
    }

    // uint64 timestamp_usecs = 6;


    pub fn get_timestamp_usecs(&self) -> u64 {
        self.timestamp_usecs
    }
    pub fn clear_timestamp_usecs(&mut self) {
        self.timestamp_usecs = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp_usecs(&mut self, v: u64) {
        self.timestamp_usecs = v;
    }

    // .network.QuorumCert quorum_cert = 7;


    pub fn get_quorum_cert(&self) -> &QuorumCert {
        self.quorum_cert.as_ref().unwrap_or_else(|| QuorumCert::default_instance())
    }
    pub fn clear_quorum_cert(&mut self) {
        self.quorum_cert.clear();
    }

    pub fn has_quorum_cert(&self) -> bool {
        self.quorum_cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quorum_cert(&mut self, v: QuorumCert) {
        self.quorum_cert = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quorum_cert(&mut self) -> &mut QuorumCert {
        if self.quorum_cert.is_none() {
            self.quorum_cert.set_default();
        }
        self.quorum_cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_quorum_cert(&mut self) -> QuorumCert {
        self.quorum_cert.take().unwrap_or_else(|| QuorumCert::new())
    }

    // bytes author = 8;


    pub fn get_author(&self) -> &[u8] {
        &self.author
    }
    pub fn clear_author(&mut self) {
        self.author.clear();
    }

    // Param is passed by value, moved
    pub fn set_author(&mut self, v: ::bytes::Bytes) {
        self.author = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_author(&mut self) -> &mut ::bytes::Bytes {
        &mut self.author
    }

    // Take field
    pub fn take_author(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.author, ::bytes::Bytes::new())
    }

    // bytes signature = 9;


    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::bytes::Bytes) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::bytes::Bytes {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.signature, ::bytes::Bytes::new())
    }
}

impl ::protobuf::Message for Block {
    fn is_initialized(&self) -> bool {
        for v in &self.quorum_cert {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.parent_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.payload)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.round = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.height = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp_usecs = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quorum_cert)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.author)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.id);
        }
        if !self.parent_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.parent_id);
        }
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.payload);
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::value_size(4, self.round, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(5, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp_usecs != 0 {
            my_size += ::protobuf::rt::value_size(6, self.timestamp_usecs, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.quorum_cert.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.author.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.author);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_bytes(1, &self.id)?;
        }
        if !self.parent_id.is_empty() {
            os.write_bytes(2, &self.parent_id)?;
        }
        if !self.payload.is_empty() {
            os.write_bytes(3, &self.payload)?;
        }
        if self.round != 0 {
            os.write_uint64(4, self.round)?;
        }
        if self.height != 0 {
            os.write_uint64(5, self.height)?;
        }
        if self.timestamp_usecs != 0 {
            os.write_uint64(6, self.timestamp_usecs)?;
        }
        if let Some(ref v) = self.quorum_cert.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.author.is_empty() {
            os.write_bytes(8, &self.author)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(9, &self.signature)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Block {
        Block::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "id",
                    |m: &Block| { &m.id },
                    |m: &mut Block| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "parent_id",
                    |m: &Block| { &m.parent_id },
                    |m: &mut Block| { &mut m.parent_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "payload",
                    |m: &Block| { &m.payload },
                    |m: &mut Block| { &mut m.payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "round",
                    |m: &Block| { &m.round },
                    |m: &mut Block| { &mut m.round },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "height",
                    |m: &Block| { &m.height },
                    |m: &mut Block| { &mut m.height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "timestamp_usecs",
                    |m: &Block| { &m.timestamp_usecs },
                    |m: &mut Block| { &mut m.timestamp_usecs },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QuorumCert>>(
                    "quorum_cert",
                    |m: &Block| { &m.quorum_cert },
                    |m: &mut Block| { &mut m.quorum_cert },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "author",
                    |m: &Block| { &m.author },
                    |m: &mut Block| { &mut m.author },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "signature",
                    |m: &Block| { &m.signature },
                    |m: &mut Block| { &mut m.signature },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Block>(
                    "Block",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Block {
        static mut instance: ::protobuf::lazy::Lazy<Block> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Block,
        };
        unsafe {
            instance.get(Block::new)
        }
    }
}

impl ::protobuf::Clear for Block {
    fn clear(&mut self) {
        self.id.clear();
        self.parent_id.clear();
        self.payload.clear();
        self.round = 0;
        self.height = 0;
        self.timestamp_usecs = 0;
        self.quorum_cert.clear();
        self.author.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Block {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Block {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QuorumCert {
    // message fields
    pub block_id: ::bytes::Bytes,
    pub state_id: ::bytes::Bytes,
    pub version: u64,
    pub round: u64,
    pub signed_ledger_info: ::protobuf::SingularPtrField<super::ledger_info::LedgerInfoWithSignatures>,
    pub parent_block_id: ::bytes::Bytes,
    pub parent_block_round: u64,
    pub grandparent_block_id: ::bytes::Bytes,
    pub grandparent_block_round: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuorumCert {
    fn default() -> &'a QuorumCert {
        <QuorumCert as ::protobuf::Message>::default_instance()
    }
}

impl QuorumCert {
    pub fn new() -> QuorumCert {
        ::std::default::Default::default()
    }

    // bytes block_id = 1;


    pub fn get_block_id(&self) -> &[u8] {
        &self.block_id
    }
    pub fn clear_block_id(&mut self) {
        self.block_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_id(&mut self, v: ::bytes::Bytes) {
        self.block_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_id(&mut self) -> &mut ::bytes::Bytes {
        &mut self.block_id
    }

    // Take field
    pub fn take_block_id(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.block_id, ::bytes::Bytes::new())
    }

    // bytes state_id = 2;


    pub fn get_state_id(&self) -> &[u8] {
        &self.state_id
    }
    pub fn clear_state_id(&mut self) {
        self.state_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_state_id(&mut self, v: ::bytes::Bytes) {
        self.state_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state_id(&mut self) -> &mut ::bytes::Bytes {
        &mut self.state_id
    }

    // Take field
    pub fn take_state_id(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.state_id, ::bytes::Bytes::new())
    }

    // uint64 version = 3;


    pub fn get_version(&self) -> u64 {
        self.version
    }
    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = v;
    }

    // uint64 round = 4;


    pub fn get_round(&self) -> u64 {
        self.round
    }
    pub fn clear_round(&mut self) {
        self.round = 0;
    }

    // Param is passed by value, moved
    pub fn set_round(&mut self, v: u64) {
        self.round = v;
    }

    // .types.LedgerInfoWithSignatures signed_ledger_info = 5;


    pub fn get_signed_ledger_info(&self) -> &super::ledger_info::LedgerInfoWithSignatures {
        self.signed_ledger_info.as_ref().unwrap_or_else(|| super::ledger_info::LedgerInfoWithSignatures::default_instance())
    }
    pub fn clear_signed_ledger_info(&mut self) {
        self.signed_ledger_info.clear();
    }

    pub fn has_signed_ledger_info(&self) -> bool {
        self.signed_ledger_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signed_ledger_info(&mut self, v: super::ledger_info::LedgerInfoWithSignatures) {
        self.signed_ledger_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signed_ledger_info(&mut self) -> &mut super::ledger_info::LedgerInfoWithSignatures {
        if self.signed_ledger_info.is_none() {
            self.signed_ledger_info.set_default();
        }
        self.signed_ledger_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_signed_ledger_info(&mut self) -> super::ledger_info::LedgerInfoWithSignatures {
        self.signed_ledger_info.take().unwrap_or_else(|| super::ledger_info::LedgerInfoWithSignatures::new())
    }

    // bytes parent_block_id = 6;


    pub fn get_parent_block_id(&self) -> &[u8] {
        &self.parent_block_id
    }
    pub fn clear_parent_block_id(&mut self) {
        self.parent_block_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent_block_id(&mut self, v: ::bytes::Bytes) {
        self.parent_block_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent_block_id(&mut self) -> &mut ::bytes::Bytes {
        &mut self.parent_block_id
    }

    // Take field
    pub fn take_parent_block_id(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.parent_block_id, ::bytes::Bytes::new())
    }

    // uint64 parent_block_round = 7;


    pub fn get_parent_block_round(&self) -> u64 {
        self.parent_block_round
    }
    pub fn clear_parent_block_round(&mut self) {
        self.parent_block_round = 0;
    }

    // Param is passed by value, moved
    pub fn set_parent_block_round(&mut self, v: u64) {
        self.parent_block_round = v;
    }

    // bytes grandparent_block_id = 8;


    pub fn get_grandparent_block_id(&self) -> &[u8] {
        &self.grandparent_block_id
    }
    pub fn clear_grandparent_block_id(&mut self) {
        self.grandparent_block_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_grandparent_block_id(&mut self, v: ::bytes::Bytes) {
        self.grandparent_block_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_grandparent_block_id(&mut self) -> &mut ::bytes::Bytes {
        &mut self.grandparent_block_id
    }

    // Take field
    pub fn take_grandparent_block_id(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.grandparent_block_id, ::bytes::Bytes::new())
    }

    // uint64 grandparent_block_round = 9;


    pub fn get_grandparent_block_round(&self) -> u64 {
        self.grandparent_block_round
    }
    pub fn clear_grandparent_block_round(&mut self) {
        self.grandparent_block_round = 0;
    }

    // Param is passed by value, moved
    pub fn set_grandparent_block_round(&mut self, v: u64) {
        self.grandparent_block_round = v;
    }
}

impl ::protobuf::Message for QuorumCert {
    fn is_initialized(&self) -> bool {
        for v in &self.signed_ledger_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.block_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.state_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.version = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.round = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signed_ledger_info)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.parent_block_id)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.parent_block_round = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.grandparent_block_id)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.grandparent_block_round = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.block_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.block_id);
        }
        if !self.state_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.state_id);
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(3, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::value_size(4, self.round, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.signed_ledger_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.parent_block_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.parent_block_id);
        }
        if self.parent_block_round != 0 {
            my_size += ::protobuf::rt::value_size(7, self.parent_block_round, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.grandparent_block_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.grandparent_block_id);
        }
        if self.grandparent_block_round != 0 {
            my_size += ::protobuf::rt::value_size(9, self.grandparent_block_round, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.block_id.is_empty() {
            os.write_bytes(1, &self.block_id)?;
        }
        if !self.state_id.is_empty() {
            os.write_bytes(2, &self.state_id)?;
        }
        if self.version != 0 {
            os.write_uint64(3, self.version)?;
        }
        if self.round != 0 {
            os.write_uint64(4, self.round)?;
        }
        if let Some(ref v) = self.signed_ledger_info.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.parent_block_id.is_empty() {
            os.write_bytes(6, &self.parent_block_id)?;
        }
        if self.parent_block_round != 0 {
            os.write_uint64(7, self.parent_block_round)?;
        }
        if !self.grandparent_block_id.is_empty() {
            os.write_bytes(8, &self.grandparent_block_id)?;
        }
        if self.grandparent_block_round != 0 {
            os.write_uint64(9, self.grandparent_block_round)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuorumCert {
        QuorumCert::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "block_id",
                    |m: &QuorumCert| { &m.block_id },
                    |m: &mut QuorumCert| { &mut m.block_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "state_id",
                    |m: &QuorumCert| { &m.state_id },
                    |m: &mut QuorumCert| { &mut m.state_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "version",
                    |m: &QuorumCert| { &m.version },
                    |m: &mut QuorumCert| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "round",
                    |m: &QuorumCert| { &m.round },
                    |m: &mut QuorumCert| { &mut m.round },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::ledger_info::LedgerInfoWithSignatures>>(
                    "signed_ledger_info",
                    |m: &QuorumCert| { &m.signed_ledger_info },
                    |m: &mut QuorumCert| { &mut m.signed_ledger_info },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "parent_block_id",
                    |m: &QuorumCert| { &m.parent_block_id },
                    |m: &mut QuorumCert| { &mut m.parent_block_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "parent_block_round",
                    |m: &QuorumCert| { &m.parent_block_round },
                    |m: &mut QuorumCert| { &mut m.parent_block_round },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "grandparent_block_id",
                    |m: &QuorumCert| { &m.grandparent_block_id },
                    |m: &mut QuorumCert| { &mut m.grandparent_block_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "grandparent_block_round",
                    |m: &QuorumCert| { &m.grandparent_block_round },
                    |m: &mut QuorumCert| { &mut m.grandparent_block_round },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QuorumCert>(
                    "QuorumCert",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QuorumCert {
        static mut instance: ::protobuf::lazy::Lazy<QuorumCert> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QuorumCert,
        };
        unsafe {
            instance.get(QuorumCert::new)
        }
    }
}

impl ::protobuf::Clear for QuorumCert {
    fn clear(&mut self) {
        self.block_id.clear();
        self.state_id.clear();
        self.version = 0;
        self.round = 0;
        self.signed_ledger_info.clear();
        self.parent_block_id.clear();
        self.parent_block_round = 0;
        self.grandparent_block_id.clear();
        self.grandparent_block_round = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QuorumCert {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuorumCert {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Vote {
    // message fields
    pub proposed_block_id: ::bytes::Bytes,
    pub executed_state_id: ::bytes::Bytes,
    pub version: u64,
    pub round: u64,
    pub author: ::bytes::Bytes,
    pub ledger_info: ::protobuf::SingularPtrField<super::ledger_info::LedgerInfo>,
    pub signature: ::bytes::Bytes,
    pub parent_block_id: ::bytes::Bytes,
    pub parent_block_round: u64,
    pub grandparent_block_id: ::bytes::Bytes,
    pub grandparent_block_round: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Vote {
    fn default() -> &'a Vote {
        <Vote as ::protobuf::Message>::default_instance()
    }
}

impl Vote {
    pub fn new() -> Vote {
        ::std::default::Default::default()
    }

    // bytes proposed_block_id = 1;


    pub fn get_proposed_block_id(&self) -> &[u8] {
        &self.proposed_block_id
    }
    pub fn clear_proposed_block_id(&mut self) {
        self.proposed_block_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_proposed_block_id(&mut self, v: ::bytes::Bytes) {
        self.proposed_block_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proposed_block_id(&mut self) -> &mut ::bytes::Bytes {
        &mut self.proposed_block_id
    }

    // Take field
    pub fn take_proposed_block_id(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.proposed_block_id, ::bytes::Bytes::new())
    }

    // bytes executed_state_id = 2;


    pub fn get_executed_state_id(&self) -> &[u8] {
        &self.executed_state_id
    }
    pub fn clear_executed_state_id(&mut self) {
        self.executed_state_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_executed_state_id(&mut self, v: ::bytes::Bytes) {
        self.executed_state_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_executed_state_id(&mut self) -> &mut ::bytes::Bytes {
        &mut self.executed_state_id
    }

    // Take field
    pub fn take_executed_state_id(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.executed_state_id, ::bytes::Bytes::new())
    }

    // uint64 version = 3;


    pub fn get_version(&self) -> u64 {
        self.version
    }
    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = v;
    }

    // uint64 round = 4;


    pub fn get_round(&self) -> u64 {
        self.round
    }
    pub fn clear_round(&mut self) {
        self.round = 0;
    }

    // Param is passed by value, moved
    pub fn set_round(&mut self, v: u64) {
        self.round = v;
    }

    // bytes author = 5;


    pub fn get_author(&self) -> &[u8] {
        &self.author
    }
    pub fn clear_author(&mut self) {
        self.author.clear();
    }

    // Param is passed by value, moved
    pub fn set_author(&mut self, v: ::bytes::Bytes) {
        self.author = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_author(&mut self) -> &mut ::bytes::Bytes {
        &mut self.author
    }

    // Take field
    pub fn take_author(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.author, ::bytes::Bytes::new())
    }

    // .types.LedgerInfo ledger_info = 6;


    pub fn get_ledger_info(&self) -> &super::ledger_info::LedgerInfo {
        self.ledger_info.as_ref().unwrap_or_else(|| super::ledger_info::LedgerInfo::default_instance())
    }
    pub fn clear_ledger_info(&mut self) {
        self.ledger_info.clear();
    }

    pub fn has_ledger_info(&self) -> bool {
        self.ledger_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ledger_info(&mut self, v: super::ledger_info::LedgerInfo) {
        self.ledger_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ledger_info(&mut self) -> &mut super::ledger_info::LedgerInfo {
        if self.ledger_info.is_none() {
            self.ledger_info.set_default();
        }
        self.ledger_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_ledger_info(&mut self) -> super::ledger_info::LedgerInfo {
        self.ledger_info.take().unwrap_or_else(|| super::ledger_info::LedgerInfo::new())
    }

    // bytes signature = 7;


    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::bytes::Bytes) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::bytes::Bytes {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.signature, ::bytes::Bytes::new())
    }

    // bytes parent_block_id = 8;


    pub fn get_parent_block_id(&self) -> &[u8] {
        &self.parent_block_id
    }
    pub fn clear_parent_block_id(&mut self) {
        self.parent_block_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent_block_id(&mut self, v: ::bytes::Bytes) {
        self.parent_block_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent_block_id(&mut self) -> &mut ::bytes::Bytes {
        &mut self.parent_block_id
    }

    // Take field
    pub fn take_parent_block_id(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.parent_block_id, ::bytes::Bytes::new())
    }

    // uint64 parent_block_round = 9;


    pub fn get_parent_block_round(&self) -> u64 {
        self.parent_block_round
    }
    pub fn clear_parent_block_round(&mut self) {
        self.parent_block_round = 0;
    }

    // Param is passed by value, moved
    pub fn set_parent_block_round(&mut self, v: u64) {
        self.parent_block_round = v;
    }

    // bytes grandparent_block_id = 10;


    pub fn get_grandparent_block_id(&self) -> &[u8] {
        &self.grandparent_block_id
    }
    pub fn clear_grandparent_block_id(&mut self) {
        self.grandparent_block_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_grandparent_block_id(&mut self, v: ::bytes::Bytes) {
        self.grandparent_block_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_grandparent_block_id(&mut self) -> &mut ::bytes::Bytes {
        &mut self.grandparent_block_id
    }

    // Take field
    pub fn take_grandparent_block_id(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.grandparent_block_id, ::bytes::Bytes::new())
    }

    // uint64 grandparent_block_round = 11;


    pub fn get_grandparent_block_round(&self) -> u64 {
        self.grandparent_block_round
    }
    pub fn clear_grandparent_block_round(&mut self) {
        self.grandparent_block_round = 0;
    }

    // Param is passed by value, moved
    pub fn set_grandparent_block_round(&mut self, v: u64) {
        self.grandparent_block_round = v;
    }
}

impl ::protobuf::Message for Vote {
    fn is_initialized(&self) -> bool {
        for v in &self.ledger_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.proposed_block_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.executed_state_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.version = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.round = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.author)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ledger_info)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.signature)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.parent_block_id)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.parent_block_round = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.grandparent_block_id)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.grandparent_block_round = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.proposed_block_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.proposed_block_id);
        }
        if !self.executed_state_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.executed_state_id);
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(3, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::value_size(4, self.round, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.author.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.author);
        }
        if let Some(ref v) = self.ledger_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.signature);
        }
        if !self.parent_block_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.parent_block_id);
        }
        if self.parent_block_round != 0 {
            my_size += ::protobuf::rt::value_size(9, self.parent_block_round, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.grandparent_block_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.grandparent_block_id);
        }
        if self.grandparent_block_round != 0 {
            my_size += ::protobuf::rt::value_size(11, self.grandparent_block_round, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.proposed_block_id.is_empty() {
            os.write_bytes(1, &self.proposed_block_id)?;
        }
        if !self.executed_state_id.is_empty() {
            os.write_bytes(2, &self.executed_state_id)?;
        }
        if self.version != 0 {
            os.write_uint64(3, self.version)?;
        }
        if self.round != 0 {
            os.write_uint64(4, self.round)?;
        }
        if !self.author.is_empty() {
            os.write_bytes(5, &self.author)?;
        }
        if let Some(ref v) = self.ledger_info.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(7, &self.signature)?;
        }
        if !self.parent_block_id.is_empty() {
            os.write_bytes(8, &self.parent_block_id)?;
        }
        if self.parent_block_round != 0 {
            os.write_uint64(9, self.parent_block_round)?;
        }
        if !self.grandparent_block_id.is_empty() {
            os.write_bytes(10, &self.grandparent_block_id)?;
        }
        if self.grandparent_block_round != 0 {
            os.write_uint64(11, self.grandparent_block_round)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Vote {
        Vote::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "proposed_block_id",
                    |m: &Vote| { &m.proposed_block_id },
                    |m: &mut Vote| { &mut m.proposed_block_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "executed_state_id",
                    |m: &Vote| { &m.executed_state_id },
                    |m: &mut Vote| { &mut m.executed_state_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "version",
                    |m: &Vote| { &m.version },
                    |m: &mut Vote| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "round",
                    |m: &Vote| { &m.round },
                    |m: &mut Vote| { &mut m.round },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "author",
                    |m: &Vote| { &m.author },
                    |m: &mut Vote| { &mut m.author },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::ledger_info::LedgerInfo>>(
                    "ledger_info",
                    |m: &Vote| { &m.ledger_info },
                    |m: &mut Vote| { &mut m.ledger_info },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "signature",
                    |m: &Vote| { &m.signature },
                    |m: &mut Vote| { &mut m.signature },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "parent_block_id",
                    |m: &Vote| { &m.parent_block_id },
                    |m: &mut Vote| { &mut m.parent_block_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "parent_block_round",
                    |m: &Vote| { &m.parent_block_round },
                    |m: &mut Vote| { &mut m.parent_block_round },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "grandparent_block_id",
                    |m: &Vote| { &m.grandparent_block_id },
                    |m: &mut Vote| { &mut m.grandparent_block_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "grandparent_block_round",
                    |m: &Vote| { &m.grandparent_block_round },
                    |m: &mut Vote| { &mut m.grandparent_block_round },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Vote>(
                    "Vote",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Vote {
        static mut instance: ::protobuf::lazy::Lazy<Vote> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Vote,
        };
        unsafe {
            instance.get(Vote::new)
        }
    }
}

impl ::protobuf::Clear for Vote {
    fn clear(&mut self) {
        self.proposed_block_id.clear();
        self.executed_state_id.clear();
        self.version = 0;
        self.round = 0;
        self.author.clear();
        self.ledger_info.clear();
        self.signature.clear();
        self.parent_block_id.clear();
        self.parent_block_round = 0;
        self.grandparent_block_id.clear();
        self.grandparent_block_round = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Vote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vote {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestBlock {
    // message fields
    pub block_id: ::bytes::Bytes,
    pub num_blocks: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestBlock {
    fn default() -> &'a RequestBlock {
        <RequestBlock as ::protobuf::Message>::default_instance()
    }
}

impl RequestBlock {
    pub fn new() -> RequestBlock {
        ::std::default::Default::default()
    }

    // bytes block_id = 1;


    pub fn get_block_id(&self) -> &[u8] {
        &self.block_id
    }
    pub fn clear_block_id(&mut self) {
        self.block_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_block_id(&mut self, v: ::bytes::Bytes) {
        self.block_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block_id(&mut self) -> &mut ::bytes::Bytes {
        &mut self.block_id
    }

    // Take field
    pub fn take_block_id(&mut self) -> ::bytes::Bytes {
        ::std::mem::replace(&mut self.block_id, ::bytes::Bytes::new())
    }

    // uint64 num_blocks = 2;


    pub fn get_num_blocks(&self) -> u64 {
        self.num_blocks
    }
    pub fn clear_num_blocks(&mut self) {
        self.num_blocks = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_blocks(&mut self, v: u64) {
        self.num_blocks = v;
    }
}

impl ::protobuf::Message for RequestBlock {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_carllerche_bytes_into(wire_type, is, &mut self.block_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_blocks = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.block_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.block_id);
        }
        if self.num_blocks != 0 {
            my_size += ::protobuf::rt::value_size(2, self.num_blocks, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.block_id.is_empty() {
            os.write_bytes(1, &self.block_id)?;
        }
        if self.num_blocks != 0 {
            os.write_uint64(2, self.num_blocks)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestBlock {
        RequestBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeCarllercheBytes>(
                    "block_id",
                    |m: &RequestBlock| { &m.block_id },
                    |m: &mut RequestBlock| { &mut m.block_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "num_blocks",
                    |m: &RequestBlock| { &m.num_blocks },
                    |m: &mut RequestBlock| { &mut m.num_blocks },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RequestBlock>(
                    "RequestBlock",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RequestBlock {
        static mut instance: ::protobuf::lazy::Lazy<RequestBlock> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RequestBlock,
        };
        unsafe {
            instance.get(RequestBlock::new)
        }
    }
}

impl ::protobuf::Clear for RequestBlock {
    fn clear(&mut self) {
        self.block_id.clear();
        self.num_blocks = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RespondBlock {
    // message fields
    pub status: BlockRetrievalStatus,
    pub blocks: ::protobuf::RepeatedField<Block>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RespondBlock {
    fn default() -> &'a RespondBlock {
        <RespondBlock as ::protobuf::Message>::default_instance()
    }
}

impl RespondBlock {
    pub fn new() -> RespondBlock {
        ::std::default::Default::default()
    }

    // .network.BlockRetrievalStatus status = 1;


    pub fn get_status(&self) -> BlockRetrievalStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = BlockRetrievalStatus::SUCCEEDED;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: BlockRetrievalStatus) {
        self.status = v;
    }

    // repeated .network.Block blocks = 2;


    pub fn get_blocks(&self) -> &[Block] {
        &self.blocks
    }
    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<Block>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<Block> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<Block> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RespondBlock {
    fn is_initialized(&self) -> bool {
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != BlockRetrievalStatus::SUCCEEDED {
            my_size += ::protobuf::rt::enum_size(1, self.status);
        }
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.status != BlockRetrievalStatus::SUCCEEDED {
            os.write_enum(1, self.status.value())?;
        }
        for v in &self.blocks {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RespondBlock {
        RespondBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BlockRetrievalStatus>>(
                    "status",
                    |m: &RespondBlock| { &m.status },
                    |m: &mut RespondBlock| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Block>>(
                    "blocks",
                    |m: &RespondBlock| { &m.blocks },
                    |m: &mut RespondBlock| { &mut m.blocks },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RespondBlock>(
                    "RespondBlock",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RespondBlock {
        static mut instance: ::protobuf::lazy::Lazy<RespondBlock> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RespondBlock,
        };
        unsafe {
            instance.get(RespondBlock::new)
        }
    }
}

impl ::protobuf::Clear for RespondBlock {
    fn clear(&mut self) {
        self.status = BlockRetrievalStatus::SUCCEEDED;
        self.blocks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RespondBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RespondBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestChunk {
    // message fields
    pub start_version: u64,
    pub target: ::protobuf::SingularPtrField<QuorumCert>,
    pub batch_size: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequestChunk {
    fn default() -> &'a RequestChunk {
        <RequestChunk as ::protobuf::Message>::default_instance()
    }
}

impl RequestChunk {
    pub fn new() -> RequestChunk {
        ::std::default::Default::default()
    }

    // uint64 start_version = 1;


    pub fn get_start_version(&self) -> u64 {
        self.start_version
    }
    pub fn clear_start_version(&mut self) {
        self.start_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_version(&mut self, v: u64) {
        self.start_version = v;
    }

    // .network.QuorumCert target = 2;


    pub fn get_target(&self) -> &QuorumCert {
        self.target.as_ref().unwrap_or_else(|| QuorumCert::default_instance())
    }
    pub fn clear_target(&mut self) {
        self.target.clear();
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: QuorumCert) {
        self.target = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut QuorumCert {
        if self.target.is_none() {
            self.target.set_default();
        }
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> QuorumCert {
        self.target.take().unwrap_or_else(|| QuorumCert::new())
    }

    // uint64 batch_size = 3;


    pub fn get_batch_size(&self) -> u64 {
        self.batch_size
    }
    pub fn clear_batch_size(&mut self) {
        self.batch_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_batch_size(&mut self, v: u64) {
        self.batch_size = v;
    }
}

impl ::protobuf::Message for RequestChunk {
    fn is_initialized(&self) -> bool {
        for v in &self.target {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_version = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.target)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.batch_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start_version != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start_version, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.target.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.batch_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.batch_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.start_version != 0 {
            os.write_uint64(1, self.start_version)?;
        }
        if let Some(ref v) = self.target.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.batch_size != 0 {
            os.write_uint64(3, self.batch_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestChunk {
        RequestChunk::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "start_version",
                    |m: &RequestChunk| { &m.start_version },
                    |m: &mut RequestChunk| { &mut m.start_version },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QuorumCert>>(
                    "target",
                    |m: &RequestChunk| { &m.target },
                    |m: &mut RequestChunk| { &mut m.target },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "batch_size",
                    |m: &RequestChunk| { &m.batch_size },
                    |m: &mut RequestChunk| { &mut m.batch_size },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RequestChunk>(
                    "RequestChunk",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RequestChunk {
        static mut instance: ::protobuf::lazy::Lazy<RequestChunk> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RequestChunk,
        };
        unsafe {
            instance.get(RequestChunk::new)
        }
    }
}

impl ::protobuf::Clear for RequestChunk {
    fn clear(&mut self) {
        self.start_version = 0;
        self.target.clear();
        self.batch_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestChunk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestChunk {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RespondChunk {
    // message fields
    pub txn_list_with_proof: ::protobuf::SingularPtrField<super::transaction::TransactionListWithProof>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RespondChunk {
    fn default() -> &'a RespondChunk {
        <RespondChunk as ::protobuf::Message>::default_instance()
    }
}

impl RespondChunk {
    pub fn new() -> RespondChunk {
        ::std::default::Default::default()
    }

    // .types.TransactionListWithProof txn_list_with_proof = 1;


    pub fn get_txn_list_with_proof(&self) -> &super::transaction::TransactionListWithProof {
        self.txn_list_with_proof.as_ref().unwrap_or_else(|| super::transaction::TransactionListWithProof::default_instance())
    }
    pub fn clear_txn_list_with_proof(&mut self) {
        self.txn_list_with_proof.clear();
    }

    pub fn has_txn_list_with_proof(&self) -> bool {
        self.txn_list_with_proof.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_list_with_proof(&mut self, v: super::transaction::TransactionListWithProof) {
        self.txn_list_with_proof = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txn_list_with_proof(&mut self) -> &mut super::transaction::TransactionListWithProof {
        if self.txn_list_with_proof.is_none() {
            self.txn_list_with_proof.set_default();
        }
        self.txn_list_with_proof.as_mut().unwrap()
    }

    // Take field
    pub fn take_txn_list_with_proof(&mut self) -> super::transaction::TransactionListWithProof {
        self.txn_list_with_proof.take().unwrap_or_else(|| super::transaction::TransactionListWithProof::new())
    }
}

impl ::protobuf::Message for RespondChunk {
    fn is_initialized(&self) -> bool {
        for v in &self.txn_list_with_proof {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.txn_list_with_proof)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.txn_list_with_proof.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.txn_list_with_proof.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RespondChunk {
        RespondChunk::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::transaction::TransactionListWithProof>>(
                    "txn_list_with_proof",
                    |m: &RespondChunk| { &m.txn_list_with_proof },
                    |m: &mut RespondChunk| { &mut m.txn_list_with_proof },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RespondChunk>(
                    "RespondChunk",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RespondChunk {
        static mut instance: ::protobuf::lazy::Lazy<RespondChunk> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RespondChunk,
        };
        unsafe {
            instance.get(RespondChunk::new)
        }
    }
}

impl ::protobuf::Clear for RespondChunk {
    fn clear(&mut self) {
        self.txn_list_with_proof.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RespondChunk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RespondChunk {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BlockRetrievalStatus {
    SUCCEEDED = 0,
    ID_NOT_FOUND = 1,
    NOT_ENOUGH_BLOCKS = 2,
}

impl ::protobuf::ProtobufEnum for BlockRetrievalStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BlockRetrievalStatus> {
        match value {
            0 => ::std::option::Option::Some(BlockRetrievalStatus::SUCCEEDED),
            1 => ::std::option::Option::Some(BlockRetrievalStatus::ID_NOT_FOUND),
            2 => ::std::option::Option::Some(BlockRetrievalStatus::NOT_ENOUGH_BLOCKS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BlockRetrievalStatus] = &[
            BlockRetrievalStatus::SUCCEEDED,
            BlockRetrievalStatus::ID_NOT_FOUND,
            BlockRetrievalStatus::NOT_ENOUGH_BLOCKS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("BlockRetrievalStatus", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for BlockRetrievalStatus {
}

impl ::std::default::Default for BlockRetrievalStatus {
    fn default() -> Self {
        BlockRetrievalStatus::SUCCEEDED
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockRetrievalStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0fconsensus.proto\x12\x07network\x1a\x11ledger_info.proto\x1a\x11tra\
    nsaction.proto\"\xd1\x03\n\x0cConsensusMsg\x12/\n\x08proposal\x18\x01\
    \x20\x01(\x0b2\x11.network.ProposalH\0R\x08proposal\x12#\n\x04vote\x18\
    \x02\x20\x01(\x0b2\r.network.VoteH\0R\x04vote\x12<\n\rrequest_block\x18\
    \x03\x20\x01(\x0b2\x15.network.RequestBlockH\0R\x0crequestBlock\x12<\n\r\
    respond_block\x18\x04\x20\x01(\x0b2\x15.network.RespondBlockH\0R\x0cresp\
    ondBlock\x126\n\x0btimeout_msg\x18\x05\x20\x01(\x0b2\x13.network.Timeout\
    MsgH\0R\ntimeoutMsg\x12<\n\rrequest_chunk\x18\x06\x20\x01(\x0b2\x15.netw\
    ork.RequestChunkH\0R\x0crequestChunk\x12<\n\rrespond_chunk\x18\x07\x20\
    \x01(\x0b2\x15.network.RespondChunkH\0R\x0crespondChunk\x120\n\tsync_inf\
    o\x18\x08\x20\x01(\x0b2\x11.network.SyncInfoH\0R\x08syncInfoB\t\n\x07mes\
    sage\"\x8d\x01\n\x08Proposal\x125\n\x0eproposed_block\x18\x01\x20\x01(\
    \x0b2\x0e.network.BlockR\rproposedBlock\x12\x1a\n\x08proposer\x18\x02\
    \x20\x01(\x0cR\x08proposer\x12.\n\tsync_info\x18\x03\x20\x01(\x0b2\x11.n\
    etwork.SyncInfoR\x08syncInfo\"\x81\x01\n\x10PacemakerTimeout\x12\x14\n\
    \x05round\x18\x01\x20\x01(\x04R\x05round\x12\x16\n\x06author\x18\x02\x20\
    \x01(\x0cR\x06author\x12\x1c\n\tsignature\x18\x03\x20\x01(\x0cR\tsignatu\
    re\x12!\n\x04vote\x18\x04\x20\x01(\x0b2\r.network.VoteR\x04vote\"\xa2\
    \x01\n\nTimeoutMsg\x12.\n\tsync_info\x18\x01\x20\x01(\x0b2\x11.network.S\
    yncInfoR\x08syncInfo\x12F\n\x11pacemaker_timeout\x18\x02\x20\x01(\x0b2\
    \x19.network.PacemakerTimeoutR\x10pacemakerTimeout\x12\x1c\n\tsignature\
    \x18\x03\x20\x01(\x0cR\tsignature\"\xec\x01\n\x08SyncInfo\x12C\n\x13high\
    est_quorum_cert\x18\x01\x20\x01(\x0b2\x13.network.QuorumCertR\x11highest\
    QuorumCert\x12C\n\x13highest_ledger_info\x18\x02\x20\x01(\x0b2\x13.netwo\
    rk.QuorumCertR\x11highestLedgerInfo\x12V\n\x14highest_timeout_cert\x18\
    \x03\x20\x01(\x0b2$.network.PacemakerTimeoutCertificateR\x12highestTimeo\
    utCert\"j\n\x1bPacemakerTimeoutCertificate\x12\x14\n\x05round\x18\x01\
    \x20\x01(\x04R\x05round\x125\n\x08timeouts\x18\x02\x20\x03(\x0b2\x19.net\
    work.PacemakerTimeoutR\x08timeouts\"\x91\x02\n\x05Block\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\x0cR\x02id\x12\x1b\n\tparent_id\x18\x02\x20\x01(\x0cR\
    \x08parentId\x12\x18\n\x07payload\x18\x03\x20\x01(\x0cR\x07payload\x12\
    \x14\n\x05round\x18\x04\x20\x01(\x04R\x05round\x12\x16\n\x06height\x18\
    \x05\x20\x01(\x04R\x06height\x12'\n\x0ftimestamp_usecs\x18\x06\x20\x01(\
    \x04R\x0etimestampUsecs\x124\n\x0bquorum_cert\x18\x07\x20\x01(\x0b2\x13.\
    network.QuorumCertR\nquorumCert\x12\x16\n\x06author\x18\x08\x20\x01(\x0c\
    R\x06author\x12\x1c\n\tsignature\x18\t\x20\x01(\x0cR\tsignature\"\x81\
    \x03\n\nQuorumCert\x12\x19\n\x08block_id\x18\x01\x20\x01(\x0cR\x07blockI\
    d\x12\x19\n\x08state_id\x18\x02\x20\x01(\x0cR\x07stateId\x12\x18\n\x07ve\
    rsion\x18\x03\x20\x01(\x04R\x07version\x12\x14\n\x05round\x18\x04\x20\
    \x01(\x04R\x05round\x12M\n\x12signed_ledger_info\x18\x05\x20\x01(\x0b2\
    \x1f.types.LedgerInfoWithSignaturesR\x10signedLedgerInfo\x12&\n\x0fparen\
    t_block_id\x18\x06\x20\x01(\x0cR\rparentBlockId\x12,\n\x12parent_block_r\
    ound\x18\x07\x20\x01(\x04R\x10parentBlockRound\x120\n\x14grandparent_blo\
    ck_id\x18\x08\x20\x01(\x0cR\x12grandparentBlockId\x126\n\x17grandparent_\
    block_round\x18\t\x20\x01(\x04R\x15grandparentBlockRound\"\xb8\x03\n\x04\
    Vote\x12*\n\x11proposed_block_id\x18\x01\x20\x01(\x0cR\x0fproposedBlockI\
    d\x12*\n\x11executed_state_id\x18\x02\x20\x01(\x0cR\x0fexecutedStateId\
    \x12\x18\n\x07version\x18\x03\x20\x01(\x04R\x07version\x12\x14\n\x05roun\
    d\x18\x04\x20\x01(\x04R\x05round\x12\x16\n\x06author\x18\x05\x20\x01(\
    \x0cR\x06author\x122\n\x0bledger_info\x18\x06\x20\x01(\x0b2\x11.types.Le\
    dgerInfoR\nledgerInfo\x12\x1c\n\tsignature\x18\x07\x20\x01(\x0cR\tsignat\
    ure\x12&\n\x0fparent_block_id\x18\x08\x20\x01(\x0cR\rparentBlockId\x12,\
    \n\x12parent_block_round\x18\t\x20\x01(\x04R\x10parentBlockRound\x120\n\
    \x14grandparent_block_id\x18\n\x20\x01(\x0cR\x12grandparentBlockId\x126\
    \n\x17grandparent_block_round\x18\x0b\x20\x01(\x04R\x15grandparentBlockR\
    ound\"H\n\x0cRequestBlock\x12\x19\n\x08block_id\x18\x01\x20\x01(\x0cR\
    \x07blockId\x12\x1d\n\nnum_blocks\x18\x02\x20\x01(\x04R\tnumBlocks\"m\n\
    \x0cRespondBlock\x125\n\x06status\x18\x01\x20\x01(\x0e2\x1d.network.Bloc\
    kRetrievalStatusR\x06status\x12&\n\x06blocks\x18\x02\x20\x03(\x0b2\x0e.n\
    etwork.BlockR\x06blocks\"\x7f\n\x0cRequestChunk\x12#\n\rstart_version\
    \x18\x01\x20\x01(\x04R\x0cstartVersion\x12+\n\x06target\x18\x02\x20\x01(\
    \x0b2\x13.network.QuorumCertR\x06target\x12\x1d\n\nbatch_size\x18\x03\
    \x20\x01(\x04R\tbatchSize\"^\n\x0cRespondChunk\x12N\n\x13txn_list_with_p\
    roof\x18\x01\x20\x01(\x0b2\x1f.types.TransactionListWithProofR\x10txnLis\
    tWithProof*N\n\x14BlockRetrievalStatus\x12\r\n\tSUCCEEDED\x10\0\x12\x10\
    \n\x0cID_NOT_FOUND\x10\x01\x12\x15\n\x11NOT_ENOUGH_BLOCKS\x10\x02b\x06pr\
    oto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
